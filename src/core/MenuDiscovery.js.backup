const { logger } = require('../utils/logger');

class MenuDiscovery {
  constructor(agent, config) {
    this.agent = agent;
    this.config = config;
    this.skipPatterns = this.parsePatterns(config.skip);
    this.includePatterns = this.parsePatterns(config.include);
    this.discoveredMenus = new Map();
  }

  /**
   * Parse comma-separated patterns into array
   * @param {string} patterns - Comma-separated patterns
   * @returns {Array} Array of patterns
   */
  parsePatterns(patterns) {
    if (!patterns || patterns === '*') return [];
    return patterns.split(',').map(p => p.trim().toLowerCase());
  }

  /**
   * Discover all menus on the current page
   * @param {number} depth - Maximum depth to explore
   * @returns {Array} Array of discovered menu items
   */
  async discoverMenus(depth = 1) {
    logger.progress(`Discovering menus (depth: ${depth})...`);
    
    try {
      // First, find all visible navigation elements
      const menus = await this.findNavigationElements();
      
      if (menus.length === 0) {
        logger.warning('No navigation menus found on the page');
        return [];
      }

      logger.success(`Found ${menus.length} potential menu items`);

      // Filter menus based on include/exclude patterns
      const filteredMenus = this.filterMenus(menus);
      
      // Check for expandable menus if depth > 1
      if (depth > 1) {
        await this.discoverSubMenus(filteredMenus, depth - 1);
      }

      return filteredMenus;
    } catch (error) {
      logger.error(`Failed to discover menus: ${error.message}`);
      throw error;
    }
  }

  /**
   * Find navigation elements using Midscene AI
   * @returns {Array} Array of menu items with metadata
   */
  async findNavigationElements() {
    try {
      // Use Midscene to find navigation menus
      const menuQuery = `
        {
          text: string,
          isExpandable: boolean,
          isVisible: boolean,
          level: number
        }[],
        找到页面中所有的导航菜单项，包括：
        - 顶部导航栏的菜单
        - 侧边栏的菜单项  
        - 下拉菜单选项
        - 可展开的菜单项
        对每个菜单项返回其文本内容、是否可展开、是否可见、菜单层级
      `;

      const menuItems = await this.agent.aiQuery(menuQuery);
      
      if (!Array.isArray(menuItems)) {
        logger.warning('AI query returned non-array result, falling back to basic detection');
        return await this.fallbackMenuDetection();
      }

      // Enrich menu items with additional metadata
      return menuItems.map((item, index) => ({
        id: `menu-${index}`,
        text: item.text || '',
        isExpandable: item.isExpandable || false,
        isVisible: item.isVisible !== false,
        level: item.level || 1,
        tested: false,
        success: null,
        error: null,
        children: []
      }));

    } catch (error) {
      logger.debug(`AI menu detection failed: ${error.message}, falling back to basic detection`);
      return await this.fallbackMenuDetection();
    }
  }

  /**
   * Fallback menu detection using basic DOM queries
   * @returns {Array} Array of basic menu items
   */
  async fallbackMenuDetection() {
    try {
      // Use Midscene to find clickable navigation elements
      const clickableElements = await this.agent.aiQuery(`
        string[], 
        找到页面中所有可点击的导航相关元素的文本，包括：
        - 导航栏链接
        - 菜单按钮
        - 侧边栏选项
        返回这些元素的文本内容列表
      `);

      if (!Array.isArray(clickableElements)) {
        return [];
      }

      return clickableElements.map((text, index) => ({
        id: `menu-${index}`,
        text: text || '',
        isExpandable: false,
        isVisible: true,
        level: 1,
        tested: false,
        success: null,
        error: null,
        children: []
      }));

    } catch (error) {
      logger.warning(`Fallback menu detection also failed: ${error.message}`);
      return [];
    }
  }

  /**
   * Filter menus based on include/exclude patterns
   * @param {Array} menus - Array of menu items
   * @returns {Array} Filtered menu items
   */
  filterMenus(menus) {
    let filtered = menus.filter(menu => menu.isVisible);

    // Apply skip patterns
    if (this.skipPatterns.length > 0) {
      filtered = filtered.filter(menu => {
        const menuText = menu.text.toLowerCase();
        return !this.skipPatterns.some(pattern => 
          menuText.includes(pattern) || menu.text.includes(pattern)
        );
      });
    }

    // Apply include patterns
    if (this.includePatterns.length > 0) {
      filtered = filtered.filter(menu => {
        const menuText = menu.text.toLowerCase();
        return this.includePatterns.some(pattern => 
          menuText.includes(pattern) || menu.text.includes(pattern)
        );
      });
    }

    logger.info(`Filtered to ${filtered.length} menu items for testing`);
    
    if (this.config.verbose) {
      filtered.forEach((menu, index) => {
        logger.debug(`  ${index + 1}. ${menu.text} ${menu.isExpandable ? '(expandable)' : ''}`);
      });
    }

    return filtered;
  }

  /**
   * Discover sub-menus for expandable menu items
   * @param {Array} menus - Parent menu items
   * @param {number} remainingDepth - Remaining depth to explore
   */
  async discoverSubMenus(menus, remainingDepth) {
    if (remainingDepth <= 0) return;

    logger.progress(`Discovering sub-menus (remaining depth: ${remainingDepth})...`);

    for (const menu of menus) {
      if (!menu.isExpandable) continue;

      try {
        logger.debug(`Checking sub-menus for: ${menu.text}`);
        
        // Try to expand the menu
        const expanded = await this.expandMenu(menu);
        
        if (expanded) {
          // Wait for sub-menu to appear
          await this.waitForSubMenu(menu);
          
          // Discover sub-menu items
          const subMenus = await this.findSubMenuItems(menu);
          
          if (subMenus.length > 0) {
            menu.children = subMenus;
            logger.success(`Found ${subMenus.length} sub-menu items for: ${menu.text}`);
            
            // Recursively discover deeper levels
            if (remainingDepth > 1) {
              await this.discoverSubMenus(subMenus, remainingDepth - 1);
            }
          }
        }
      } catch (error) {
        logger.debug(`Failed to discover sub-menus for ${menu.text}: ${error.message}`);
      }
    }
  }

  /**
   * Expand a menu item to reveal sub-menus
   * @param {object} menu - Menu item to expand
   * @returns {boolean} Whether the menu was successfully expanded
   */
  async expandMenu(menu) {
    try {
      // Use Midscene to click on the expandable menu
      await this.agent.aiTap(`点击展开 "${menu.text}" 菜单`);
      
      // Wait a moment for expansion animation
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Check if menu is now expanded
      const isExpanded = await this.agent.aiBoolean(
        `"${menu.text}" 菜单是否已经展开显示子菜单`
      );
      
      return isExpanded;
    } catch (error) {
      logger.debug(`Failed to expand menu ${menu.text}: ${error.message}`);
      return false;
    }
  }

  /**
   * Wait for sub-menu to appear after expansion
   * @param {object} parentMenu - Parent menu item
   */
  async waitForSubMenu(parentMenu) {
    try {
      await this.agent.aiWaitFor(
        `"${parentMenu.text}" 的子菜单已经显示出来`,
        { timeout: 2000 }
      );
    } catch (error) {
      logger.debug(`Sub-menu wait timeout for ${parentMenu.text}`);
    }
  }

  /**
   * Find sub-menu items for an expanded menu
   * @param {object} parentMenu - Parent menu item
   * @returns {Array} Array of sub-menu items
   */
  async findSubMenuItems(parentMenu) {
    try {
      const subMenuQuery = `
        string[],
        找到 "${parentMenu.text}" 菜单下的所有子菜单项的文本内容
      `;

      const subMenuTexts = await this.agent.aiQuery(subMenuQuery);
      
      if (!Array.isArray(subMenuTexts)) {
        return [];
      }

      return subMenuTexts.map((text, index) => ({
        id: `submenu-${parentMenu.id}-${index}`,
        text: text,
        isExpandable: false,
        isVisible: true,
        level: parentMenu.level + 1,
        parent: parentMenu.id,
        tested: false,
        success: null,
        error: null,
        children: []
      }));

    } catch (error) {
      logger.debug(`Failed to find sub-menu items for ${parentMenu.text}: ${error.message}`);
      return [];
    }
  }

  /**
   * Check if a menu item is currently expanded
   * @param {object} menu - Menu item to check
   * @returns {boolean} Whether the menu is expanded
   */
  async isMenuExpanded(menu) {
    try {
      return await this.agent.aiBoolean(
        `"${menu.text}" 菜单是否处于展开状态`
      );
    } catch (error) {
      logger.debug(`Failed to check expansion state for ${menu.text}: ${error.message}`);
      return false;
    }
  }

  /**
   * Collapse an expanded menu
   * @param {object} menu - Menu item to collapse
   * @returns {boolean} Whether the menu was successfully collapsed
   */
  async collapseMenu(menu) {
    try {
      await this.agent.aiTap(`收起 "${menu.text}" 菜单`);
      
      // Wait for collapse animation
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const isCollapsed = await this.agent.aiBoolean(
        `"${menu.text}" 菜单是否已经收起`
      );
      
      return isCollapsed;
    } catch (error) {
      logger.debug(`Failed to collapse menu ${menu.text}: ${error.message}`);
      return false;
    }
  }

  /**
   * Get all menu items flattened (including sub-menus)
   * @param {Array} menus - Menu tree
   * @returns {Array} Flattened array of all menu items
   */
  getFlattenedMenus(menus) {
    const flattened = [];
    
    for (const menu of menus) {
      flattened.push(menu);
      if (menu.children && menu.children.length > 0) {
        flattened.push(...this.getFlattenedMenus(menu.children));
      }
    }
    
    return flattened;
  }

  /**
   * Get menu statistics
   * @param {Array} menus - Menu tree
   * @returns {object} Statistics object
   */
  getMenuStats(menus) {
    const flattened = this.getFlattenedMenus(menus);
    
    return {
      total: flattened.length,
      level1: menus.length,
      expandable: flattened.filter(m => m.isExpandable).length,
      tested: flattened.filter(m => m.tested).length,
      successful: flattened.filter(m => m.success === true).length,
      failed: flattened.filter(m => m.success === false).length
    };
  }
}

module.exports = MenuDiscovery; 